3.1 기본 데이터 타입(숫자,불린값,문자열,null,undefnied)
    모든 숫자는 실수로 취급
    문자열 생성시 수정 불가능
    null은 조건문을 이용시 ===연산자 이용
3.2 참조데이터 타입 - 객체
    객체 생성   
        1. 객체 함수 - new 객체()
        2. 객체 생성 - 리터럴 방식 - 객체 = {객체 프로퍼티 값: value값}
    객체 표기
        1.객체 프로퍼티 추가시 기존거면 갱신되고, 
          아니면 새로운 프로퍼티 추가하여 값을 할당 
        2. -(빼기 연산자)가 들어간 프로퍼티는 
           무조건 대괄호([])표기법을 써야함
    객체 출력 - for in 문 사용
        foo = {
                name : adf,
                age:30,
            }
        var = a;<br>
        for(a in foo){
            console.log(a,foo[a]);
        };
        results
            name foo,
            age 30,
            major engineering
    객체 프로퍼티 삭제 
         1.delete연산자 
         2.객체 자체는 삭제 할 수 없음
3.3 참조 타입의 특성
    1. 객체의 값 updating 가능
        ex)
        const 객체1 ={name:"10"};
        let 객체2 = 객체1;
        객체2.name = "hi";
        객체1 => {name : "hi"};로 바뀜 
    2. 객체 비교
        == 동등 연산자 이용
        객체 자체를 비교함, 객체의 프로퍼티의 값이 아님
            객체값 = {프로퍼티:값}
            프로퍼티 값 = 값 위{} 안에 있는 값임
                const a = 10;
                const b = 10;

                objA = {value:10};
                objB = {value:10};
                let objC = objB;

                console.log(a==b);//true    
                console.log(objA==objB);//false
                console.log(objB==objC);//true
    3. 참조에 의한 함수 호출
        객체는 인자로 쓰인 객체의 값이 updating되면,
        객체의 실제 값도 바뀜
        하지만, 기본 값들은 함수 안에서 선언된다면 함수 안에서만 적용됨
            ex)
            const a = 10;
            const objA = {value:10};
            const b = 11;

            const changeArg = (num,obj) => {
                num = 200;
                obj.value = 200;
                console.log(num);//200
                console.log(obj.value); 10에서 200으로 갱신됨
                console.log(b);//11
            };
            changeArg(a,objA);//200,200,11

            console.log(a);//10
            console.log(objA.value);//200 실제값도 200으로 갱신됨
3.4 프로토타입 - 객체의 부모 (__proto__) shift+- 각각 2번씩
    객체에는 부모 역할을 하는 객체가 존재하며
    거기에 속하는 객체는 부모객체의 메서드를 사용할 수 있다.
    ex)
        const a = {
            name : "foo",
            age : 30,
        };

        console.log(a.toString());//[object Object] 
            toString()은 object를 반환하는 객체임

        console.dir(a); //Object age: 30 name: "foo" __proto__: Object

        __proto__: Object 
            이것이  바로 프로토타입 객체의 부모임
            google에서는 이것을 __proto__로 표시함
3.5 배열
    하나의 변수안에 데이터의 list를 가지는 것

        배열 length 프로퍼티
            length값 구하기
            ex)
                let arr = [];
                console.log(arr.length); //0

                arr[0] = 0;
                arr[1] = 1;
                arr[2] = 2;
                arr[100] = 100;
                console.log(arr.length);//101
                //but 실제 메모리는 100만틈 할당 되지 않고 
                //있는 인덱스 만큼 할당 된다

            //length 변경
            ex)
                const array = [0,1,2];
                console.log(array.length);//3

                array.length =  5;
                console.log(array);//[0, 1, 2, empty × 2]

                array.length = 2;
                console.log(array);//[0, 1]
                //length의 벗어나는 실제 값은 삭제된다
                //인덱스 2의 값 2가 삭제됨

            //배열의 표준 메서드 
                //length 프로퍼티를 사용
                //push()는 배열 끝에 추가하는 표준 배열 메서드
                //왜냐하면 length는 가장큰 인덱스 +1 이고 push는 한개를 추가하므로 +1에 해당함
                 ex)
                    let arrayA = ["a","b","c","d","e"];

                    //push()메서드 추가

                    arrayA.push("a");
                    console.log(arrayA);//["a", "b", "c", "d", "e", "a"]

                    //length 값 추가후 push()쓰기

                    arrayA.length = 7;
                    arrayA.push("a+");
                    console.log(arrayA);//["a", "b", "c", "d", "e", "a", empty, "a+"]  
                    추가된거는 undefnied로 채워지고 push로 된 요소가 끝에서 추가됨  

        배열 vs 객체
          ex)
            배열
            const colorsArray = ["red","blue"];
            console.log(colorsArray[0]);//red
            console.log(colorsArray[1]);//blue
            객체
            const colorsObject = {
                "0" : "red",
                "1" : "blue",
            };
            console.log(colorsObject[0]);//red
            console.log(colorsObject[1]);//blue

            // type of 연산자
            console.log(typeof colorsArray, typeof colorsObject);//object object 둘다 객체임

            // length 프로퍼티
            console.log(colorsArray.length, colorsObject.length);//2 undefined 객체는 length가없음

            //배열 표준 메서드 push()
            colorsArray.push("yellow");
            colorsObject.push("yellow"); => 에러뜸
            console.log(colorsArray);//["red", "blue", "yellow"]
            
            결과
                객체  __proto__ -> Object.prototype(객체의 부모)

                배열  __proto__ -> (배열의 부모) Array.prototype  __proto__ 
                ->(Array.prototype의 부모) Object.prototype 

                따라서 배열은 둘의 메서드를 모두 가지고 있다
                //_proto_ ex)
                    const emptyArray = [];
                    const emptyObject = {};

                    console.dir(emptyArray.__proto__);//ar;ray꺼에 + __proto__: object
                    console.dir(emptyObject.__proto__);//__proto__: object만 

        배열의 프로퍼티 추가
            배열도 객체 이므로 프로퍼티 생성가능 
            하지만, 배열과 객체는 따로따로이므로 
            배열의 가장큰 인덱스가 변하지 않는한 
            배열의 length의 크기는 변하지 않음
            배열도 객체처럼 "key: value"형태로 있음

        배열 요소 나열 - 프로퍼티 있을 경우
            ex)
            let proof = ["zero","one","two"];
            proof.color = "mustade";
            proof.name = "fuckking proof";
            console.log(proof);

            //for in 문은 불필요한 프로퍼티 출력
                let p;
                for(p in proof){
                    console.log(p,proof[p]);
                };//0 zero, 1 one, 2 two, color mustade, name fuckking proof

            //for문 사용하면 배열의 요소만 출력 가능
                let i;
                for(i=0;i<proof.length;i++){
                    console.log(i,proof[i]);
                };//0 "zero", 1 "one", 2 "two"        
        
        배열 요소 삭제
            //delete연산자 사용
                배열요소만 지워지고 undefnied로 지워진 인덱스가 채워짐
                삭제되는 배열의 인덱스는 안지워짐

            //splice( start, deleteCount, item) 배열 메서드
                1. start 가 배열 위치, 삭제를 시작할 배열의 위치부터 삭제하는 거임
                2. deleteCount가 start에서 지정한 시작 위치부터 삭제할 요소의 수 start에서 수만큼 삭제
                3. item은 삭제할 위치에 추가할 요소

                ex)
                    let v = ["x","y","z"];
                    v.splice(0,1,"v");
                    console.log(v);//["v", "y", "z"]
                    //x삭제됨 "v"로 바꿈
                    console.log(v.length);//2        
    
        Array 생성자 함수
            생성자 함수는 반드시 new연산자와 함꼐 있어야한다

                -호출된 인자가 1개이면 인자 만큼의 length를 가진 빈배열을 가진다

                    let j = new Array(3);
                    console.log(j);//[undefnied,undefnied,undefnied]
                    console.log(j.length);//3

                -1개 이상일떄는 호출된 인자를 요소로 가지며, 인자개수가 length가 된다.

                    let k = new Array(1,2,3);
                    console.log(k);//[1, 2, 3]
                    console.log(k.length);//3        
3.6 기본타입으로 표준 메서드 쓰기
     //숫자 메서드 출력
        -toExponenetial(인자)로 몇번쨰 소수점자리까지 리턴 할건지 결정
            const g = 1;
            console.log(g.toExponential(2));//1.00e+0
        -toFixed 몇번쨰 자리에서 반올림
        -toPrecision() 몇개의 숫자를 반활한건지
    //문자열 메서드
        -charAt() 몇번쨰 글자를 반활 할건지
            console.log("hi".charAt(0));//h
        -indexOf는 뒤에서 몇번쨰 자리 문자를 반환 0부터 시작
        -substring(인수,인수) 문자열 나타냄 (시작,끝)   
3.7 연산자
    1. + 연산자 숫자는 더하기 문자열 연결 연산도 됨
         단, 띄어쓰기 없음
            let h = "hi";
            let l = "me";
            console.log(h+l);//hime

    2. typeOf연산자 데이터 타입 볼수 있는 연산자
        기억해야할 것 null은 object 배열도 object 함수는 function으로 나옴
     
    3. == 동등 연산자 와 === 일치 연산자
        == 동등 연산자는 타입을 변환후 같은지 봄
        ===일치 연산자는 타입 변환하지 않고 비교 완전 값이 같아야함

    4. !!연산자 
        불린값 반환

    5. !는 아님을 뜻함 !true = false